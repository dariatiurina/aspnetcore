@using Microsoft.AspNetCore.Components.QuickGrid


@if (RendererInfo.IsInteractive)
{
    <button id="finish-loading-button" @onclick="@(async () => await FinishLoadingAsync(200))">Finish loading</button>
}
<br/>

@if (boolLoad != "no condition")
{
    <p id="loadDone">@boolLoad</p>
}

<div id="async-container" style="height: 500px; overflow-y: auto;">
    <QuickGrid @ref="asyncGrid" TGridItem="DataItem" ItemsProvider="GetItemsAsync" Virtualize="true" ItemSize="25">
    <PropertyColumn Property="@(p => p.Id)" class="async-id">
    </PropertyColumn>
    <PropertyColumn Property="@(p => p.SecondNum)" class="async-second">
        <PlaceholderTemplate>
            <strong class="async-placeholder">LOADING DATA</strong>
        </PlaceholderTemplate>
    </PropertyColumn>
</QuickGrid>
</div>  

@code {
    record DataItem(int Id, int SecondNum);

    QuickGrid<DataItem> asyncGrid;

    int asyncTotalItemCount = 200;
    int asyncCancellationCount = 0;
    string boolLoad = "no condition";
    TaskCompletionSource asyncTcs = new TaskCompletionSource();

    private async ValueTask<GridItemsProviderResult<DataItem>> GetItemsAsync(GridItemsProviderRequest<DataItem> request)
    {
        var loadingTask = asyncTcs.Task;
        var registration = request.CancellationToken.Register(() => CancelLoadingAsync(request.CancellationToken));

        await loadingTask;

        registration.Dispose();

        var items = Enumerable.Range(request.StartIndex, request.Count ?? 200)
            .Select(i => new DataItem(i, i * 2))
            .ToArray();

        return GridItemsProviderResult.From(items, asyncTotalItemCount);
    }

    async Task FinishLoadingAsync(int totalItemCount)
    {
        asyncTotalItemCount = totalItemCount;
        asyncTcs.SetResult();
        asyncTcs = new TaskCompletionSource();

        if (asyncGrid is not null)
        {
            await asyncGrid.RefreshDataAsync();
            boolLoad = "condition";
        }
        else
        {
            boolLoad = "asyncGrid null";
        }
        StateHasChanged();
    }

    void CancelLoadingAsync(System.Threading.CancellationToken cancellationToken)
    {
        asyncTcs.TrySetCanceled(cancellationToken);
        asyncTcs = new TaskCompletionSource();

        asyncCancellationCount++;

        StateHasChanged();
    }
}
